const DATA = [
    {
        id : 1,
        "title" : "Introduction to WebSocket",
        "image" : "https://www.donskytech.com/wp-content/uploads/2022/09/Using-WebSocket-in-the-Internet-of-Things-IOT-projects-WebSockets.jpg",
        "description" : "WebSocket ကို chat app တို့ auction app တို့လိုစသည်ဖြင့် client နဲ့ server ကြားမှာ real time communication လုပ်ဖို့လိုအပ်လာတဲ့အခါမျိုးတွေမှာအသုံးပြုလေ့ရှိကြပါတယ်။WebSocket က client နဲ့ server ကြားမှာ socket connection တစ်ခုဖန်တီးပေးပြီးတော့ အဲ့ဒီ connection ကနေမှတစ်ဆင့် client ဘက်ကဖြစ်ဖြစ် server ဘက်ကဖြစ်ဖြစ် (any direction/bi-direction) data တွေပို့နိုင်အောင်ပြုလုပ်ပေးပါတယ်။ ပုံမှန် HTTP requests တွေက user interaction/trigger တစ်ခုခုလိုအပ်တဲ့အပြင် cookies နဲ့ headers တွေပါစုပုံပို့တဲ့အတွက် overhead တတ်စေပါတယ်။ WebSocket မှာတော့ သိသိသာသာ overhead ကိုလျော့ချထားတဲ့အတွက်  latency နည်းတဲ့ system တွေ real time communication လုပ်ဖို့လိုတဲ့ system တွေမှာအသုံးပြုဖို့ ပိုသင့်တော်ပါတယ်။ HTTP ရော WebSocket ရော client-server communication လုပ်ဖို့အတွက်သုံးပေမယ့် ကွာခြားချက်တွေရှိတယ်။ အဓိကကွာခြားချက်ကတော့ WebSocket ရဲ့အလုပ်လုပ်ပုံက အပေါ်မှာပြောခဲ့သလို bidirectional functioning ဖြစ်ပြီးတော့ HTTP ကတော့ unidirectional ပုံစံနဲ့သွားပါတယ်။ Bidirectional ဖြစ်တဲ့ WebSocket ကို real time ဖြစ်ရမယ့် development တွေမှာအသုံးပြုပြီးတော့ unidirectional, stateless ဖြစ်တဲ့ HTTP ကိုတော့ REST development လိုနေရာမျိုးတွေမှာအဓိကအသုံးပြုကြပါတယ်။ Connection terminate ဖြစ်တဲ့ပုံစံကလည်း HTTP နဲ့ WebSocket မှာမတူညီကြဘူး။ WebSocket မှာ client server connection ဖြစ်နေတဲ့အချိန်မှာ တစ်ဖက်ဖက်က disconnect ဖြစ်သွားတာနဲ့ connection terminate ဖြစ်တယ်။ HTTP မှာတော့ client က request တစ်ခုပို့တယ်၊ server က response လုပ်တယ်၊ ပြီးတာနဲ့ connection က terminate ဖြစ်တယ်။ WebSocket မှာလိုမျိုး party နှစ်ခုလုံးအတွက် alive/persistent ဖြစ်တဲ့ connection ပုံစံမျိုးမရှိဘူး။ HTTP, HTTPS ရှိသလိုမျိုး WebSocket မှာလည်း ws, wss ဆိုပြီး scheme တွေရှိတယ်။ ဒီ scheme တွေသုံးခြင်းအားဖြင့် client နဲ့ server က WebSocket protocol ရဲ့ စံသတ်မှတ်ချက်တွေကိုလိုက်နာမယ်လို့ဆိုနိုင်ပါတယ်။ WebSocket connection တစ်ခုစတင်တော့မယ်ဆို client ဘက်ကနေအရင်ဆုံး HTTP နဲ့ WebSocket handshake request တစ်ခုအရင်ပို့ရတယ်၊ server ကလက်ခံလိုက်ပြီးဆို client နဲ့ server ကြားထဲမှာ full duplex connection တစ်ခုရသွားပြီးတော့ data communicate လုပ်လို့ရပြီ။ full duplex ဆိုတာက ဒီ party နှစ်ခုလုံးကအချင်းချင်း တစ်ဖက်နဲ့တစ်ဖက် simultaneously (တစ်ပြိုင်နက်တည်း) ဆက်သွယ်လို့ရတာကိုဆိုလိုခြင်းဖြစ်ပါတယ်။ အခုရေးခဲ့တဲ့ request, response, coummicate လုပ်တဲ့အပိုင်းက ဒီထက်ပိုပြီးကျယ်ပြန့်ပါတယ်၊ အချိန်ရရင်အသေးစိတ်ထပ်ရေးပေးပါမယ်။ WebSocket ကို real time development တွေမှာအသုံးပြုတယ်လို့အပေါ်မှာပြောခဲ့တယ်၊ ဘယ်လိုမျိုးနေရာတွေလည်းဆိုတော့ client ကလည်း data တွေကိုအဆက်မပြတ်ပို့နေ၊ server ဘက်ကလည်းအဆက်မပြတ် response ပြန်လုပ်ပေးဖို့လိုအပ်နေတဲ့ system မျိုးတွေပေါ့။ ဥပမာ trading website တွေ chat app တွေဆို UI ကို refresh လုပ်စရာမလိုဘဲ data တွေကိုတော်လျှောက် ပို့/လက်ခံဖို့လိုအပ်ပါတယ်။ အဆက်မပြတ် request/response လုပ်တဲ့နေရာမှာလည်း latency ကလည်းနည်းရမယ်၊ ဒါမှသာ အသုံးပြုနေတဲ့ system က smooth ဖြစ်မှာ latency များလို့ data transimission မှာ delay ဖြစ်သွားရင် system ကကောင်းကောင်းအသုံးပြုလို့မရနိုင်တော့ဘူး။ဒီလောက်ဆိုရင် WebSocket အကြောင်းအကြမ်းဖျင်းနားလည်သွားပြီး အသုံးပြုနိုင်မယ့် scenario တွေကိုလည်းသဘောပေါက်သွားမယ်လို့ထင်ပါတယ်။ အချိန်ရရင်တစ်ချို့အပိုင်းလေးတွေကို အသေးစိတ်ထပ်ရေးပေးပါမယ်။"
    }
    ,
    {
        id : 2,
        "title" : "Token Based Authentication",
        "image" : "https://www.okta.com/sites/default/files/styles/tinypng/public/media/image/2020-12/TokenBasedAuthentication.png?itok=zXMogDjG",
        "description" : "အရှေ့မှာတုန်းက Cookie based authentication အကြောင်းပြောဖြစ်တာနဲ့ တစ်လက်စတည်း Token အကြောင်းကိုပါ ဆက်ဖတ်ချင်သူတွေအတွက် ရေးပြီးသားရှိတဲ့အတွက်ကြောင့် လိုအပ်တဲ့အပိုင်းတစ်ချို့ကိုပဲထပ်ထည့်ရေးပြီး ရေးပီးသား article link တွေဆီပဲပြန်ညွှန်ပေးလိုက်ပါမယ်။ အရင်ဆုံးဘာကြောင့် Token based ကိုသုံးရတယ်၊ cookie approach နဲ့ဘာတွေကွာလည်းဆိုတာနားလည်ဖို့လိုပါတယ်။ Token ကိုသုံးရတဲ့ အဓိကအကြောင်းအရင်းကတော့ cookie based မှာရှိတဲ့ shortcomings တွေကိုဖြည့်ဆည်းပြီးအသုံးပြုဖို့ပါပဲ။ cookie တွေလိုမဟုတ်ဘဲ သုံးရတာ ပိုပြီး flexible ပိုဖြစ်တယ်၊ cross-platform သုံးလို့ရတဲ့အတွက်ကြောင့်လည်းပါတာပေါ့။ Cross-platform ဖြစ်သွားတဲ့အတွက်ကြောင့်လည်း API တွေမှာအသုံးဝင်တယ်။  scalable လုပ်ရတာပိုလွယ်တယ်။ ဘာကြောင့်ဒီလိုတွေကွာသွားရလဲဆိုတော့ stateful ဖြစ်တာနဲ့ မဖြစ်တာက အဓိက ကွာခြားသွားတာပါပဲ။ Cookie approach မှာတုန်းကတော့ server ဘက်က data (sessions) တွေ create လုပ်ပြီး client လက်ကိုပို့ပေးတယ်။ client ဘက်ကလည်း sessionID ကို cookie ထဲမှာ hold လုပ်ထားတယ်၊ server ဘက်ကလည်း Lookup ပြန်လုပ်နိုင်ဖို့အတွက် server ဘက်ခြမ်းမှာ session data တွေသိမ်းထားတယ်။ ဒီအတွက်ကြောင့်လည်း cookie approach ဟာ stateful ဖြစ်သွားတယ်။ တစ်ခြားတစ်ဘက်မှာတော့ Token က server ဘက်ကပဲဖန်တီးပေးလိုက်တာမှန်ပေမယ့် သိမ်းဆည်းထားခြင်းမရှိဘူး။ Client ကပေးလိုက်တဲ့ info တွေကိုပဲ sign & encoded လုပ်ထားတဲ့ string ကိုပဲ token အနေနဲ့ပြန်ပေးလိုက်တာ။ Verification အတွက်ကိုလည်း အဲ့ token ကိုပဲ decode လုပ် sign ကိုပြန်စစ်လုပ်လိုက်တာပဲ(အသေးစိတ်ကို အောက်က articles တွေမှာဖတ်ရန် :D)။ အဓိကပြောချင်တာကတော့ token approach ဟာအဲ့အတွက်ကြောင့် stateless ဖြစ်သွားတယ်။ stateless ဖြစ်သွားတဲ့အတွက် cookie approach တုန်းကအခက်အခဲရှိခဲ့တဲ့အရာတွေကို အဆင်ပြေပြေသုံးနိုင်သွားတယ်။"
    }
    ,
    {
        id :3,
        "title" : "Cookie Based Authentication",
        "image" : "https://aprogrammer.blog/storage/blog/images/1652351080.png",
        "description" : "ဒီအကြောင်းကတစ်ခြား articles တွေရေးတုန်းကတစ်စတစ်စ ခဏခဏပြောဖူးပေမယ့် သေချာမရေးဖူးတာနဲ့ ရေးဖို့ဖြစ်လာပါတယ်ဆိုပါတော့။ Btw, long time no see. Authentication လုပ်တယ်ဆိုတာ တစ်နည်းအားဖြင့်တော့ user ကို access ပေးဖို့အတွက် client နဲ့ server ကြားမှာ user info ကို exchange လုပ်တဲ့ သဘောတရားပါပဲ။ ဒီလို exchange လုပ်တဲ့ပုံစံကလည်း အမျိုးမျိုးရှိတယ်။ အဲ့ထဲကမှ ကျနော်ကဒီနေ့ cookie ကိုအခြေခံပြီးလုပ်တဲ့ပုံစံကို ရေးသွားမှာဖြစ်ပါတယ်။ အလုပ်လုပ်ပုံကိုအသေးစိတ်တစ်ဆင့်ခြင်းပြန်ပြီးတော့ breakown လုပ်ရမယ်ဆို ပထမဦးဆုံး user (browser) က server ဆီကို login ဝင်ဖို့အတွက် credentials တွေပို့လိုက်ပါတယ်။ Server ဘက်ကနေစစ်ဆေးပြီးတော့ မှန်ကန်တယ်ဆို session တစ်ခုထုတ်ပြီးတော့ server ဘက်ခြမ်းမှာသိမ်းထားပါတယ်။ သိမ်းတဲ့နေရာကတော့ အခြေအနေပေါ်မူတည်ပြီးတော့ DB, Memory, File စသည်ဖြင့်ကွဲပြားနိုင်ပါသေးတယ်။ ရွေးချယ်တဲ့ storage ပေါ်မူတည်ပြီးတော့ scalable လုပ်ရတာခက်တဲ့ issue တွေလည်းရှိတတ်ပါတယ်။ (ဒီအကြောင်းကတော့ နောက်ကြုံမှသပ်သပ်ထပ်ရေးပါမယ်။) ပြီးတာနဲ့ browser ဘက်ကို cookie ပြန်ပေးလိုက်ပါတယ်။ အဲ့ cookie ထဲမှာ sessionID လို့ခေါ်တဲ့ unique ဖြစ်တဲ့ ID တစ်ခုပါတယ်။ user ကို verfity ပြန်လုပ်ဖို့အတွက်သုံးမှာ။ cookie ကိုပို့လိုက်တဲ့နေရာမှာလည်း cookie header ပါသွားမှာဖြစ်ပြီးတော့ expiry date, domain အစရှိတာတွေပါ pass ပေးလိုက်လို့ရတယ်။ Browser ဘက်ကရလာတဲ့ cookie ကိုသိမ်းထားပြီးတော့ နောက် requests တွေတိုင်းမှာထည့်ပို့သွားတယ်။ Server ဘက်ကလည်း cookie (sessionID) ကိုရပြီဆို ခုနက generate လုပ်ပြီးသိမ်းထားတဲ့ session နဲ့ browser ဘက်ကပါလာတဲ့ sessionID ကိုပြန်တိုက်စစ်ပြီး verify လုပ်တယ်။ Final step အနေနဲ့ user က logout လုပ်လိုက်ပြီဆို server ဘက်ကလည်း session ကို remove လုပ်သလို browser ဘက်ကလည်း cookie ကို remove လုပ်လိုက်ပါတယ်။ အခုအပေါ်မှာပြောခဲ့တာတွေအားလုံးက automated process ဖြစ်ပြီးတော့ developer ဘက်က လိုက်လုပ်ပေးစရာ များများစားစားမလိုအပ်ပါဘူး။ ဒါကြောင့်လုပ်ကိုင်ရတာလွယ်ပေမယ့် ထည့်သွင်းစဉ်းစားရမယ့်အချက်လေးတွေလည်းရှိပါတယ်။ Cookie based auth ကိုသုံးမယ်ဆို XSS နဲ့ CSRF အတွက်ပါ security measurements တွေထည့်စဉ်းစားပေးဖို့လိုအပ်ပါတယ်။ ခက်ခက်ခဲခဲတော့လည်းမဟုတ်ပေမယ့် သတိချပ်ထားရမယ့် အချက်လေးတွေဖြစ်ပါတယ်။ Cookie header setup လုပ်ကတည်းက ပြင်ဆင်ထားလို့ရပါတယ်။ Cookie မှာ secure, httponly flag ထည့်တာတို့၊ CSRF အတွက် samesite setup ထည့်ထားရမှာတို့ဖြစ်ပါတယ်။ And definitely not for APIs Cookie based ကိုတော့ API တွေ develop လုပ်တဲ့နေရာမှာသုံးဖို့မသင့်တော်ပါဘူး။ ဘာလို့လဲဆိုတော့ ဥပမာ ကိုယ့် API ကို access လုပ်မယ့် Platform အမျိုးမျိုးမှာ cookie ကိုသုံးရတာအဆင်ပြေတဲ့ platform လည်းရှိနိုင်သလို မပြေနိုင်မယ့် platform မျိုးတွေလည်းရှိနိုင်ပါတယ်။ ဒါကြောင့် ဒီနေရာမှာတော့ cookie အစား token based လိုအရာမျိုးတွေကိုသုံးကြပါတယ်။ "
    }
    ,
    {
        id : 4,
        "title" : "Local Storage , a bad idea ?",
        "image" : "https://aprogrammer.blog/storage/blog/images/1636117113.png",
        "description" : "Local storage ရဲ့သဘောတရားကတော့ အားလုံးသိထားပြီးလောက်လို့ယူဆတဲ့အတွက် အသေးစိတ်မရှင်းပြတော့ပါဘူး။  JavaScript ကိုသုံးပြီးတော့ Browser ထဲမှာယာယီ information တွေသိမ်းနိုင်တဲ့ feature တစ်ခုလို့ဆိုနိုင်ပါတယ်။ Local storage ကိုသုံးတာကောင်းလား၊ မကောင်းဘူးလား ဘာကြောင့် မကောင်းတာလဲစတဲ့ အချက်တွေကို ရေးသွားမှာဖြစ်ပါတယ်။ Local storage ကိုသုံးခြင်းအားဖြင့် data သိမ်းရတာလွယ်ကူတယ်၊ JS code နည်းနည်းရေးလိုက်ရုံပဲ။ cookie တွေထက်လည်းသုံးရပိုလွယ်တယ်၊ ဘာကြောင့်လဲဆိုတော့ cookie နဲ့သိမ်းဖို့ဆို web server လိုအပ်လာပြီ၊ ဒါကြောင့် Backend language တစ်ခုခုလည်းမဖြစ်မနေလိုအပ်လာမယ်။ Local storage ကတော့ဒါတွေမလိုအပ်ဘူး။  နောက်တစ်ချက်ကတော့ storage size က cookie ထက်စာရင်ပိုရတယ်။ cookie က max storage 4K လောက်ပဲရတဲ့အချိန်မှာ Local storage က 5MB ထိရတယ်။ သုံးရတာလွယ်တယ်၊ size များများရတယ် ဆိုတဲ့အချက်တွေကြောင့် စိတ်ဝင်စားဖို့ကောင်းပါတယ်။ သို့ပေမယ့် Local storage က ကောင်းတဲ့အချက်တွေထက် drawbacks(တန်ပြန်မကောင်းတဲ့အချက်တွေ) က ပိုများနေတယ်လို့ပြောနိုင်ပါတယ်။ 5MB ထိသိမ်းနိုင်တယ်ဆိုပေမယ့် string type သီးသန့်ပဲသိမ်းနိုင်တယ်။ data တွေကို serialize လုပ်ပြီးသိမ်းနိုင်ပေမယ့်လို့ string သီးသန့်ပဲရတာကတော့ မကောင်းဘူး။ Async မဟုတ်ဘဲ synchronous ပုံစံနဲ့ပဲအလုပ်လုပ်ပါတယ်၊ ဆိုလိုချင်တာက performance အတွက်မကောင်းဘူး၊ background processing jobs တွေ workers လိုမျိုးတွေအတွက်ဆို အဆင်မပြေနိုင်ပါဘူး။ ဒီထိတော့ ကောင်းတဲ့အချက်၊ မကောင်းတဲ့အချက်တွေက balance ဖြစ်နေသေးတယ်မြင်နိုင်ပါတယ်။ storage ကလည်း 5MB ထက်မကျော်ဘူး၊ high performance လည်းဖြစ်စရာမလိုဘူး၊ နည်းနည်းနှေးလည်းအဆင်ပြေတယ်၊ sensitive ဖြစ်တဲ့ information တွေလည်း (user information, credit card number, phone number etc.) သိမ်းစရာမလိုဘူးဆိုရင်တော့ local storage ကိုသုံးနေနိုင်ပါသေးတယ်။ ဒါပေမယ့် drawbacks တွေကဒီထက်ပိုပြီးရှိနေသေးတယ်။ ကျနော် အပေါ်မှာ sensitive ဖြစ်တဲ့ information တွေလို့ပြောသွားတယ်၊ sensitive ဖြစ်တဲ့ information တွေသိမ်းလို့မရလို့လား၊ Technically သိမ်းလို့တော့ရတယ်၊ ဒါပေမယ့် secure ဖြစ်မှာမဟုတ်ဘူး။ ဘာကြောင့်လဲဆိုတော့ local storage ကိုယ်တိုင်ကိုက secure storage mechanism မဟုတ်ဘူး။ ပုံမှန်ပေါ့ပေါ့ပါးပါး key value pair လောက်ပဲသုံးဖို့အတွက် လုပ်ထားတဲ့ alternative storage ပုံစံတစ်မျိုးပါပဲ။ နောက်တစ်ခုကတော့ JavaScript ကိုသုံးပြီးတော့(XSS attack) browser ထဲမှာရှိတဲ့ storage values တွေကိုလှမ်းပြီးတော့ access လုပ်နိုင်ခြေ possibilities အများကြီးရှိနေတဲ့အတွက် လုံခြုံမှုအားဖြင့်လည်း အတော်လေးနည်းသွားမှာဖြစ်ပါတယ်။ နောက်တစ်ခုကတော့ API tokens တွေ JWT tokens တွေလိုမျိုးကိုလည်း Local storage ထဲမှာမသိမ်းမိဖို့လိုပါတယ်။ အပေါ်ကအချက်တွေနည်းတူ token ပေါက်သွားနိုင်တဲ့အတွက်ဖြစ်ပါတယ်။ tokens တွေနဲ့ပတ်သတ်ပြီးတော့ ပြီးခဲ့တဲ့အပတ်က articles တွေကိုပြန်လည်ဖတ်ရှုနိုင်ပါတယ်။ ဟုတ်ပြီ၊ local storage ကမကောင်းဘူးဆိုတော့ alternative storage အဖြစ်တစ်ခြားဘာတွေသုံးနိုင်မလဲ။ တော်တော်များများသုံးနေကျဖြစ်တဲ့ sessionID ဖန်တီးပြီး cookie ထဲမှာထည့်သုံးပြီးတော့လည်း sensitive information တွေကိုသိမ်းဆည်းနိုင်ပါတယ်။ Login system တော်တော်များများကိုလည်း session ID နဲ့ဖန်တီးထားတာတွေကိုတွေ့နိုင်ပါတယ်။ session ID login နဲ့ပတ်သတ်ပြီးတော့ ထပ်ဖတ်နိုင်ဖို့ comment မှာလင့်ခ်ထည့်ပေးထားပါတယ်။ ယေဘုယျသဘောတရားကတော့ cookie ထဲက session ID ကိုလှမ်းထုတ်ယူပြီး တစ်ခြား secure storage ထဲမှာသိမ်းထားတဲ့ sensitive data တွေကိုလှမ်း access လုပ်တာဖြစ်ပါတယ်။ Cookie ကိုသုံးပြီဆိုတာနဲ့တစ်ပြိုင်နက် ဒီအချက်တွေကိုဂရုစိုက်ရပါမယ်။ httpOnly flag (for client side’s scriptings)    -    SameSite=strict (for CSRF attacks) -    secure=true (making sure cookies are communicating through secure connection) နောက်တစ်မျိုးကတော့ Indexed DB ကိုသုံးတာ, data ပိုများများသိမ်းချင်တယ်၊ သိမ်းထားတဲ့ data တွေကိုပိုပြီးတော့ စီမံရလွယ်ကူချင်တယ်ဆိုသုံးနိုင်ပါတယ်။ JavaScript object-oriented database လို့လည်းဆိုပါတယ်။ sensitive data တွေအတွက်အကောင်းဆုံးလို့ပြောလို့မရပေမယ့် local storage ထက်တော့အများကြီးပိုကောင်းပါတယ်။ Syn ရော Async ရောရမယ် စသည်ဖြင့်အများကြီးပိုကောင်းတဲ့အချက်တွေရှိပါတယ်။ အသေးစိတ်ကို mozilla org မှာသွားဖတ်ကြည့်နိုင်ပါတယ်။"
    }
    ,
    {
        id : 5,
        "title" : "Json ဆိုတာ",
        "image" : "https://codebeautify.org/blog/images/json-full-form.webp",
        "description" : "Json ဆိုတဲ့အသုံးအနှုန်းက မစိမ်းကြပါဘူး၊ သုံးဖူးကြတယ်၊ ကြားဖူးကြတယ်။ ဒီ data ကို Json နဲ့သိမ်းထားလိုက်လေ၊ အဲ့ဒီလိုတဲ့ data ကို ဟို Json ကနေလှမ်းယူသုံးလိုက်၊ Json နဲ့ return ပြန်ပေးလိုက် စသည်ဖြင့် အမျိုးမျိုးတွေ့ဖူးကြုံဖူးကြတယ်။ ဒီနေ့အဲ့ဒီ Json အကြောင်းကိုနည်းနည်းလေးထပ်လေ့လာကြည့်ကြပါမယ်။ Json အကြောင်းကိုမပြောခင် ဘာကြောင့် Json ဆိုတာလိုအပ်လာတာလဲဆိုတာကိုအရင်စဉ်းစားဖို့လိုပါတယ်။ ဆိုပါစို့ ကျနော်တို့ပုံမှန် web app တွေရေးပြီဆို Database ရှိတယ်၊ လိုတဲ့ data တွေ database နဲ့ချိတ်ဆက်ပြီးအသုံးပြုကြတယ်၊ ဒါပေမယ့်ဒါတွေက permanent ဖြစ်တဲ့ data တွေအတွက်၊ temporary data တွေအတွက်ဆိုရင် Database ကိုတိုက်ရိုက်အသုံးမပြုကြတော့ဘူး၊ သုံးတဲ့အခြေအနေလည်းရှိပေမယ့် ရှားပါတယ်။ တစ်ချို့ကျတော့လည်း sqlite file လေးတွေဆောက်ပြီးသိမ်းကြတယ်။ ထားပါတော့ ဒီနေရာမှာ temporary data လေးသိမ်းချင်တာတစ်ခုတည်းနဲ့ Database နဲ့ချိတ်ဆက်နေရမယ်ဆို ဝန်များသလိုဖြစ်ပါတယ်။ နောက်တစ်မျိုးဘယ်လိုသိမ်းလို့ရမလဲ ဆက်စဉ်းစားမယ်ဆို file လေးတွေလုပ်ပြီး data ထည့်သိမ်းလိုက်လို့ရတယ်၊ Text file တွေလိုမျိုးပေါ့။ ပြဿနာကဘာလဲဆိုတော့ သိမ်းတာကတော့ထည့်လိုက်တော့ဝင်သွားပြီဆိုပေမယ့် အဲ့ဒီ data တွေကို ပြန်သုံးချင်လို့ယူလိုက်တဲ့အခါမှာ format မကျတော့တဲ့အတွက် အလွယ်တကူယူသုံးလို့မရတော့ပါဘူး။ ဒီအတွက်ကြောင့် စသွင်းမယ့်အချိန်တည်းက structure ကျအောင်သိမ်းထားမှ ပြန်ထုတ်သုံးတဲ့အချိန်မှာလည်း အလွယ်တကူပြန်လည်အသုံးချနိုင်မယ်။ ဒါဆိုရင် ကျနော်တို့ serialization ဆိုတာကိုသုံးလို့ရတယ်။ serialize လုပ်တယ်ဆိုတာက data တွေကို format တစ်ခုအဖြစ်ပြောင်းချပေးလိုက်တာ၊ အဲ့ဒီ format ကလည်း universal format ဖြစ်တဲ့အတွက် ဘယ်လိုအခြေအနေမျိုးမဆိုပြန်ထုတ်သုံးရလွယ်ကူတယ်။ Programming language တိုင်းမှာလည်း serialize, unserialize တွေလုပ်နိုင်ဖို့အတွက်လည်းထောက်ပံ့ပေးထားကြပါတယ်။  https://en.wikipedia.org/wiki/Serialization  ------serialization ကိုနားလည်ပြီဆို Json အကြောင်းအထူးတစ်လည်ပြောစရာမလိုတော့ဘူး။ Json ဆိုတာကလည်း data serialization အတွက်သုံးတဲ့ human-readable ဖြစ်တဲ့ format တစ်ခုပဲဖြစ်ပါတယ်။ Json format ချထားတဲ့ data တွေပေါ့။ Json ကိုဘယ်လိုပုံစံနဲ့ရေးလဲဆိုတော့ JavaScript Object Notation ပုံစံနဲ့ရေးပါတယ်၊ ဒါကြောင့်လည်းသူ့ကို အတိုကောက် json လို့ခေါ်ရခြင်းဖြစ်ပါတယ်။ သိထားပြီးကြလောက်ပေမယ့်လိုရမယ်ရ အောက်မှာ sample လေးထပ်ထည့်ပေးလိုက်ပါမယ်။ ကျနော် blog အစမှာရေးထားတဲ့ Json ကိုဘာကြောင့်သုံးတာလဲဆိုတဲ့ Why case ကိုပြန်ကောက်ကြည့်ရအောင်။ Json ကိုလက်ရှိအထိ software application တွေကြားမှာ data တွေအသယ်၊ အပို့လုပ်ဖို့အတွက်အသုံးများနေကြတုန်း။ Json ဖန်တီးရတာလည်းလွယ်ကူတဲ့အပြင် data တွေပြန်လည်ထုတ်ယူအသုံးပြုရတဲ့နေရာမှာလည်း လွယ်ကူတယ်။ Programming Languages တွေမှာလည်း Json အသုံးပြုနိုင်ဖို့ support လုပ်ထားကြပြီးသား။ Json သုံးဖို့အတွက်ဆိုပြီး သတ်မှတ်ထားတဲ့ Language ရယ်လို့မရှိဘူး၊ Language Independent ဖြစ်တယ်။ ဒါကြောင့်မို့အထက်မှာ ဥပမာပေးထားတဲ့ temporary data သိမ်းဖို့အတွက်တို့ဘာတို့အပြင် တစ်ခြားသော fixed ဖြစ်တဲ့ setting data တို့၊ မတူညီတဲ့ platform တွေကြားမှာ အသုံးပြုနိုင်ဖို့ API Data အဖြစ်တို့သုံးချင်တာတွေအတွက်လည်း Json ကိုသုံးရခြင်းဖြစ်ပါတယ်။ တစ်ခုသိထားစေချင်တာက Json က abstract data type မဟုတ်ဘူး၊ abstract data type ကို အကျဉ်းချုပ်ပြီး ထပ်ပြောရမယ်ဆို ကျနော်တို့ပုံမှန်သုံးနေကြ Primitive values တွေဖြစ်တဲ့ Int, Char အစရှိတာတွေသည် abstract data type တွေ၊ ဘာကြောင့်လည်းဆိုတော့ အသုံးပြုတဲ့သူတွေက data type ရဲ့ purpose ကိုပဲသိတယ်၊ Int ဆို integer တွေအတွက်ဆိုတာမျိုး အဲ့ဒီ data type တွေရဲ့ Implementation detail ကတော့ hide လုပ်ထားတယ်။ Detail Implementation ကို hide လုပ်ထားတယ်ဆိုရင် abstract ဖြစ်တယ်။ ဒါကြောင့်အဲ့တာတွေသည် abstract data type ၊ Json မှာတော့ သူရဲ့  implementation ကို hide လုပ်ထားတာမရှိဘူး၊ ဒါကြောင့်သူက abstract data type စာရင်းထဲမဝင်ဘူး။ အရေးတော့မကြီးပေမယ့် ဗဟုသုတအဖြစ်မှတ်ထားလို့ရတာပေါ့။"
    }
    ,
    {
        id : 6,
        "title" : "API & REST API ဆိုတာဘာလဲ၊ ဘာကြောင့် REST သုံးကြတာလဲ။",
        "image" : "https://aprogrammer.blog/storage/blog/images/1611919819.png",
        "description" : "API & REST API ဆိုတာဘာလဲ၊ ဘာကြောင့် REST သုံးကြတာလဲ။ ပြီးခဲ့တဲ့အပတ်က JSON အကြောင်းပြောရင်းနဲ့ REST API အကြောင်းပြောမယ်ဆိုပြီး စိတ်ကူးရခဲ့တာနဲ့ ရေးလိုက်ပါတယ်။ REST အကြောင်းကိုမပြောခင်မှာ API ဆိုတဲ့အကြောင်းလေးနဲ့ Intro လုပ်သွားပါမယ်။ ဒါဆို API ဆိုတာဘာလဲမသိတဲ့သူပါစပြီးဖတ်လို့ရသွားပါမယ်။ article တစ်ခုထဲမှာပဲ API, REST API, Why REST API ဆိုတဲ့ အပိုင်းတွေစုံအောင်ပြောထားတဲ့အတွက် နည်းနည်းတော့ ယေဘုယျဆန်သွားပါမယ်။ API ရဲ့ အရှည်ကောက်ကို Application Program Interface လို့ခေါ်ပါတယ်။ Interface ဆိုတဲ့သဘောတရားအတိုင်း တစ်ခြားတစ်ဘက်ကလှမ်းယူအသုံးပြုနိုင်အောင် ထုတ်နုတ်ပေးထားခြင်းကိုဆိုလိုတာပါ။ နားလည်လွယ်အောင်ပြောရရင် ထမင်းဆိုင်သွားလိုက်ရင် ထမင်းဆိုင်က စားသုံးသူတွေအတွက်ထုတ်ပေးထားတဲ့ menu interface ဆိုတာရှိပါတယ်။ ကြက်သားဟင်း၊ ငါးဟင်းစသည်ဖြင့်ပေါ့၊ Interface ကိုကောင်းအောင်ထုတ်ပေးနိုင်တဲ့ အဆင့်မြင့်တဲ့ ထမင်းဆိုင်တွေဆို description ဆိုတာလေးပါ ပါသေး၊ ကြက်သားဟင်းကို ဘာတွေနဲ့ဘယ်လိုချက်ထားတယ်စသည်ဖြင့်ပေါ့။ ဒီသဘောကို Programming မှာဆက်စပ်ပြရမယ်ဆိုရင် ကျနော်တို့အခုသုံးနေတဲ့ Programming Language တွေမှာ conditional statement စစ်တာတို့ looping ပတ်တာတို့သည် Language ကပေးထားတဲ့ ထုတ်ပေးထားတဲ့ API တွေကိုခေါ်သုံးနေတာပဲဖြစ်ပါတယ်။ နောက်ဥပမာတစ်ခုပြရမယ်ဆို ကျနော်တို့ website or application ထဲမှာ Google map ကြီးကို embed လုပ်ထားမယ်ဆို ဒါသည် Google Map API ကိုလှမ်းသုံးထားတာပဲဖြစ်ပါတယ်။ API ကိုအသေးစိတ်ထပ်ရှင်းရမယ်ဆို ပိုကျယ်ပြန့်ပေမယ့် ဒီဆောင်းပါးမှာတော့ ဒီလောက်နဲ့ပဲအရှိန်သတ်ထားလိုက်ပါမယ်။ အဓိကကတော့ API ဆိုတာ services တွေကြားမှာ အချင်းချင်းချိတ်ဆက်ပြီး အလုပ်လုပ်နိုင်အောင် ဖန်တီးပေးထားတဲ့အရာလို့ ယေဘုယျမှတ်ထားလို့ရပါတယ်။ ဒါဆိုရင် API သဘောတရားတော့သိပြီ။ REST API ဆိုတာဘာလဲပေါ့။ ကျနော်တို့အပေါ်မှာပြောခဲ့တဲ့ APIဆိုတာသည်ယေဘုယျသဘောတရားဖြစ်ပြီးတော့ API အမျိုးအစားအမျိုးမျိုးရှိနိုင်ပါတယ်။ System တစ်ခုထဲမှာ build in ပါတဲ့ API တွေလား၊ Web API လား၊ Embeded API လားအစရှိသဖြင့်အမျိုးမျိုးရှိနိုင်ပါတယ်။ REST API ဆိုတာကတော့ HTTP protocol ကိုအသုံးပြုထားတဲ့ API architecture တစ်ခုလို့ဆိုလို့ရပါတယ်။ ပြီးတော့ တစ်ကယ့် RESTFUL ဖြစ့်တဲ့ API တစ်ခုဖြစ်လာဖို့အတွက် စည်းမျဉ်းစည်းကမ်းလေးတွေရှိတယ်။ အဲ့ဒီအတွက်လည်းကျနော်နောက်ပိုင်း သက်သက်တစ်ခုထပ်ရေးပေးသွားပါမယ်။ လောလောဆယ်ဖတ်ထားချင်ရင် REST ကိုဖန်တီးခဲ့တဲ့ Roy T. Fielding ရဲ့ blog ကိုသွားဖတ်လို့ရပါတယ်။ https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven  နည်းနည်းရှုပ်မယ်ထင်ရင်အောက်က link က  Guiding Principles of REST အပုဒ်ကိုသွားဖတ်နိုင်ပါတယ်။ https://restfulapi.net/  ---REST API လည်းအပေါ်ကလိုပါပဲ၊ အကျဉ်းချုပ်ပြီးနားလည်ရလွယ်အောင်ဖော်ပြပေးထားပါတယ်၊ ထပ်ပြီးအများကြီးကျယ်ပြန့်ပါသေးတယ်။  ဆိုတော့ API အကြောင်းနဲ့ REST အကြောင်းကို သိပြီဆိုရင် ဘာလို့ REST API ကိုသုံးကြလဲဆိုတာကိုဆက်လို့ရပါပြီ။ REST ကအခုလတ်တလောအထိကို popular ဖြစ်နေတဲ့ web API architecture တစ်ခုဖြစ်နေတုန်းပါပဲ။ ဘာလို့လဲဆိုတော့အောက်ကအချက်တွေကြောင့်လို့ပြောလို့ရပါတယ်။ REST API ကို implement လုပ်ရတဲ့သူကိုယ်တိုင်ကလည်းလွယ်သလို ဖတ်ရတဲ့သူ၊ သုံးရမယ့်သူကလည်း နားလည်ရလွယ်ပါတယ်။ HTTP ကိုသုံးပြီးတော့အလုပ်လုပ်တာဖြစ်တဲ့အတွက် ပုံမှန် HTTP မှာရှိတဲ့ GET, POST, PUT စတဲ့ဒီလိုအခေါ်အဝေါ်တွေနဲ့ ကျွမ်းကျင်ထားပြီးသားသူတွေအတွက် REST API ကလည်းပိုပြီးနားလည်ရလွယ်ကူခြင်းဖြစ်ပါတယ်။  နောက်တစ်ချက်က REST က stateless ဖြစ်ပါတယ်။ stateless ဖြစ်သည့်အားလျှော်စွာ request တွေနဲ့ပတ်သတ်ပြီးသိမ်းဆည်းထားခြင်းမရှိသည့်အတွက် ဝင်လာသမျှ request တိုင်းကို efficiency ကောင်းကောင်းနဲ့ကိုယ်တွယ်နိုင်တယ်၊ ဥပမာ stateless မဖြစ်ဘူးဆို server side မှာ သိမ်းတဲ့ session file တွေများလာတာနဲ့အမျှ server resource ကိုနေရာယူစေပါတယ်။ stateless ဖြစ်ပြီဆို server resource ကိုဝင်လာတဲ့ request တွေပေါ်ကိုပဲသုံးတယ်၊ request ကို process လုပ်ပြီးပြီဆိုရင်လည်း ဖျက်ချပစ်လိုက်တယ်၊ ဘာမှသိမ်းထားတာမရှိဘူး။ ဒီလိုသဘောတရားဖြစ်ပါတယ်။ Stateless ဖြစ်တဲ့အတွက်နောက်ဆက်တွဲကောင်းတဲ့အချက်က scalable လုပ်ရတာပိုကောင်းတယ်၊ scalable ဆိုတာ server ကို traffic request ပေါ်မူတည်ပြီး လိုသလိုကြီးမယ်၊သေးမယ်၊ ဒီလိုမျိုးအလွယ်မှတ်ထားလို့ရမယ်။ ဘာလို့ scalable လုပ်ရတာပိုကောင်းတာလဲဆိုတော့ ဥပမာ ကိုယ့်ရဲ့ server architecture က load balancer ခံထားပြီးတော့အနောက်မှာ server တွေကို horizontal scaling လုပ်ထားတယ်ဆိုပါစို့၊ အကယ်လို့သာ stateless မဖြစ်ဘူးဆိုရင် request တစ်ခုဝင်လာမယ် session သိမ်းစရာရှိတယ်ဆို server1 မှာသိမ်းထားတယ်၊ နောက်တစ်ကြိမ်မှာသာ အဲ့ request က server1 ကိုမရောက်ဘူး၊ scaling architecture အရ တစ်ခြား server ရောက်သွားမယ်ဆိုရင် ခုနက session ကရှိမှာမဟုတ်တော့ဘူး။ ဒီလိုအခက်အခဲမျိုးကိုဖြေရှင်းလို့ရပေမယ့် ဒီနေရာမှာဆိုလိုချင်တာက stateless သာဖြစ်ခဲ့မယ်ဆို သိမ်းဆည်းစရာမရှိတဲ့အတွက် scaling architecture နဲ့လည်းဘာမှသွားညှိစရာမလိုတော့ပါဘူး။ နောက်ပြီးတော့ REST က response ပြန်တဲ့နေရာမှာ JSON ကိုသုံးတယ်ဆိုပေမယ့် XML နဲ့တစ်ခြား Format တွေနဲ့လည်း response ပြန်ပေးနိုင်ပါတယ်။ JSON ကိုသုံးရတဲ့ ရည်ရွယ်ချက်က JSON သည် XML ထက်ပိုပြီးတော့ size သေးတယ်၊ Parsing လုပ်ရတာပိုကောင်းတယ်။ ဒါပေမယ့်ခုနကပြောခဲ့သလိုပဲ header type ပေါ်မူတည်ပြီး JSON လည်းပြန်ပေးနိုင်သလို XML နဲ့အခြား format တွေလည်းပြန်ပေးနိုင်တယ်။ ဆိုလိုချင်တာကတော့ REST က flexible ဖြစ်တယ်ဆိုတာပေါ့။ JSON နဲ့ပတ်သတ်ပြီးဖတ်ချင်ရင်တော့အောက်က link မှာဝင်ဖတ်နိုင်ပါတယ်။  https://www.facebook.com/aprogrammerblog/posts/442399753778309 --တစ်ခြားအသုံးဝင်တဲ့အချက်တွေလည်းရှိသေးတယ်၊ ဥပမာ client က response ကို cache ရိုက်ထားချင်တာတို့ဘာတို့တွေနဲ့ပတ်သတ်ပြီးလည်း လုပ်နိုင်တဲ့ options တွေရှိတယ်။ ကျနော်အခုပြောခဲ့တဲ့အရာတွေကိုဖတ်ပြီးတော့မှ အပေါ်မှာပေးထားတဲ့ REST API Guiding Principles တွေဖတ်ကြည့်မယ်ဆို ပိုနားလည်လွယ်သွားမယ်ထင်ပါတယ်။ ထပ်ထည့်ရေးချင်တာလေးတွေရှိပေမယ့် စာရှည်နေလို့နောက်မှပဲသက်သက်ထပ်ထည့်ရေးသွားပါတော့မယ်။ လိုအပ်တာတွေတွေ့ရင်လည်း ဝင်ရောက်ဖြည့်စွက်ပေးသွားနိုင်ပါတယ်။ ကျေးဇူးတင်ပါတယ်။"
    }
    ,
    {
        id : 7,
        "title" : "CDN အကြောင်းတစ်စေ့တစ်စောင်း",
        "image" : "https://aprogrammer.blog/storage/blog/images/101.png",
        "description" : "CDN ဘယ်လိုအလုပ်လုပ်လဲ မသိခင်မှာ ပထမဦးဆုံး cdn ကဘာလဲဆိုတာ သိဖို့လိုပါတယ်။ ကိုယ်က Web Developer တစ်ယောက်ဆိုရင်တော့ cdn နဲ့သိပ်မစိမ်းပါဘူး။ ကိုယ့်ရဲ့ project ထဲမှာ cdn ကယူထားတဲ့ js တွေ jquery တွေ စသည်ဖြင့် assets တွေအများကြီးရှိပါတယ်။ ဘာလို့ cdn ကိုသုံးရလည်းဆိုတော့ request delay ဖြစ်နိုင်တဲ့ problem ကြောင့်၊ ဥပမာဆိုပါစို့၊ ကိုယ်က ကိုယ့် project ထဲမှာ js file တစ်ခုကို load လုပ်လိုက်တယ်။ ကိုယ်က Yangon မှာ ဒါပေမယ့် အဲ့ဒီ load လုပ်မယ့် file က US လို အရမ်းဝေးတဲ့ နေရာတစ်ခုက hosting မှာရှိတယ်ဆိုရင် physical distance က အရမ်းဝေးနေတယ်။ အဲ့ဒီ physical distance များတဲ့ issue ကြောင့် ကိုယ့် website ကလည်း load တတ်တဲ့ နေရာမှာ delay ဖြစ်နိုင်ပါတယ်။ CDN ကိုသုံးရတဲ့ ရည်ရွယ်ချက်က အပေါ်မှာပြောခဲ့တဲ့ physical distance ကို တတ်နိုင်သမျှ လျော့ချပြီး site ကို delay မဖြစ်စေဖို့ပေါ့။ ဒီလောက်ဆို CDN အကြောင်းသိပြီ၊ CDN ဘယ်လို အလုပ်လုပ်လဲဆိုတာ ဆက်ကြည့်ရအောင်။ ခုနက ပြောခဲ့တဲ့ physical distance ကို လျော့အောင်လုပ်ဖို့ဆို request လုပ်မယ့် file တွေက geolocation တွေအများကြီးမှာရှိဖို့လိုတယ်။ ဒါမှသာ ဥပမာ ခုနကပြောခဲ့တဲ့ Yangon ကလူက US server က file ကို access လုပ်မယ်ဆို US server file ကအကယ်လို့သာ အဲ့ဒီ file ကို US, UK, China, Singapore တို့မှာထားထားမယ်ဆိုရင် Yangon ကလူက US ထိသွားစရာမလိုဘဲ အနီးစပ်ဆုံး Singapore အထိပဲသွားခြင်းဖြင့် source နဲ့ destination ရဲ့ physical distance ကိုလျော့နိုင်ပါတယ်။ geolocation အများကြီးမှာထားတာကို points of presence (PoP) လို့ခေါ်ပါတယ်။ Pop တစ်ခုဆီတိုင်းမှာ request လာလုပ်မယ့် content တွေအတွက် serve လုပ်ပေးနိုင်မယ့် caching server တွေရှိပါတယ်။ အပေါ်မှာ ပြောခဲ့တဲ့အတိုင်း file ရဲ့ original server က US မှာရှိပေမယ့် Yangon ကလူ request လှမ်းလုပ်မယ်ဆို singapore Pop ကနေ response ပြန်လုပ်ပေးနိုင်ပါတယ်။ Pop အကြောင်းထပ်ပြောရင် Pop ဆိုတာတစ်နည်းအားဖြင့် data centers တွေပဲ။ geolocation တွေအလိုက်မှာ ထားထားတဲ့ data center တွေပေါ့၊ ဒါမှသာ request လုပ်တဲ့သူနဲ့ အနီးဆုံး short path က Pop က response ပြန်လုပ်ပေးနိုင်မှာ၊ တစ်နည်းအားဖြင့် physical distance ကိုလျော့ပေးနိုင်မှာ။ Pop ထဲမှာဘာတွေထပ်ရှိမလဲဆိုရင် caching server တွေထပ်ရှိမယ်။ Caching servers ထဲမှာတော့ cache လုပ်ထားတဲ့ files တွေသိမ်းထားတယ်၊ request လုပ်ခံရမယ့် file တွေပေါ့။ သူရဲ့ အဓိက ရည်ရွယ်ချက်က request လာမယ့် source website ရဲ့ bandwidth consumption ကိုလျော့ချပြီး load performance ကိုတတ်စေဖို့ပဲ။ Caching server ထဲမှာ file တွေကိုသိမ်းတယ်ဆိုတဲ့နေရာမှာ SSD, HDD, RAM တွေကိုသုံးပြီးသိမ်းတယ်။ ဘယ်ဟာကို သုံးတယ်ဆိုတာကတော့ file request များတယ် နည်းတယ်အပေါ်မူတည်ပြီး သုံးတယ်။ ဥပမာ request ခနခန လာတဲ့ file တွေဆို RAM ပေါ်တင်ထားခြင်းအားဖြင့် response မြန်မြန်လုပ်ပေးနိုင်တယ်၊ ဒီလိုသဘောမျိုးပေါ့။ တစ်ခြား CDN နဲ့ပတ်သတ်ပြီး deep dive လုပ်လို့ရသေးပေမယ့် ဒီလောက်သိထားတယ်ဆိုရင် အဆင်ပြေပြီလို့ထင်ပါတယ်။ Thank you for reading."
    }
    ,
    {
        id : 8,
        "title" : "Design pattern ဆိုတာ",
        "image" : "https://aprogrammer.blog/storage/blog/images/91.png",
        "description" : "Design pattern ဆိုတာ ကျနော်တို့ software implementation လုပ်တဲ့အချိန်မှာ သင့်တော်ရင် သင့်တော်သလိုသုံးသွားဖို့၊ တစ်နည်းအားဖြင့်ပြောရရင် software design issue လေးတွေကို cover လုပ်ချင်လို့သုံးတယ်လို့ပြောလည်းရပါတယ်။ ဥပမာပြောရရင် problem A, B, C ရှိတယ်၊ problem A ကို solution လုပ်ပေးမယ့် Design Pattern A ဆိုတာရှိမယ်၊ B ရော C ရောထိုနည်းလည်းကောင်းပဲပေါ့၊ ဒါပေမယ့် pattern B ကို problem A ကိုသွားသုံးလို့မရဘူး။ ဘာလို့လဲဆိုတော့ design pattern တိုင်းမှာ သူ့ရဲ့ purpose နဲ့ scope ရှိတယ်၊ မတူကြဘူး၊ ဒါကြောင့်မို့လို့ မတူညီတဲ့ problem တွေအတွက် အကုန် အလားတူ သွားသုံးလို့မရဘူး၊ ဒါဆိုရင် problem ကို identification လုပ်ဖို့လိုတာပေါ့၊ အမှန်ပဲ design pattern တွေကို apply လုပ်ရတဲ့နေရာမှာလဲ ဒီအပိုင်းက အရေးကြီးဆုံးပဲ၊ ကိုယ့် problem ရဲ့ သဘောတရားကို ကျကျနန နားလည်ထားမှသာ design pattern မှားမသုံးမိမှာဖြစ်ပါတယ်။ နောက်တစ်ခုက design pattern ဆိုတာ plugin တွေ libraries တွေမဟုတ်ဘူးဆိုတာပါ၊ plugin တွေ library တွေဆိုရင် ကိုယ်လိုချင်တဲ့ codes တွေ implementation တွေအကုန်ပါပြီးသား ကိုယ်က အဲ့ဒီ function တွေကိုလှမ်းသုံးလိုက်ရုံပဲ၊ ဆိုလိုချင်တာက အစအဆုံး ကိုယ်က ကိုယ်လိုချင်တဲ့ပုံစံကို ရေးစရာမလိုဘူး၊ library developer တွေ abstract ထုတ်ပေးထားတာ ဆွဲသုံးရုံပဲ။ Design pattern ကကျဒီလိုမဟုတ်ဘူး၊ form ပုံစံလေးပဲချပေးထားတာ အဲ့ဒီ form ထဲမှာ guide lines တွေပါတယ်။ ဥပမာ problem A အတွက် solution design pattern A ကိုလိုက်သုံးတော့မယ်ဆို A pattern ကချမှတ်ထားတဲ့ အချက်တွေကို လိုက်နာပြီးတော့ implement လုပ်သွားရပါမယ်။ Implement လုပ်ပြီးသွားပြီဆို သက်ဆိုင်တဲ့ problem ကိုဖြေရှင်းနိုင်ရုံသာမက code ရဲ့ architect level မြင့်လာမယ်၊ application က ပို robust ဖြစ်လာမယ့်အပြင် code ရဲ့ readability ပိုကောင်းလာတဲ့အတွက် team ထဲက developer အချင်းချင်း interaction လုပ်ရတာပိုကောင်းလာလိမ့်မယ်။ OOP Design patterns မှာကျနော်အပေါ်က ပြောထားတဲ့ pattern တွေရဲ့ scope တွေ purpose အပေါ်မူတည်ပြီး အဓိကအားဖြင့် ၃ မျိုးခွဲထွက်ထားပါတယ်။ OOP Design pattern တွေစာအုပ်ဖတ်ချင်တယ်ဆို ဒီစာအုပ်ကောင်းပါတယ်။ Elements of Reusable Object-Oriented Software, GOF design pattern လို့လဲခေါ်ပါတယ်။ Behavioral , Creational and Structural ဆိုပြီးတော့ပါ။ အဲ့ဒီ module တစ်ခုခြင်းဆီအောက်မှာ design patterns တွေရှိပါတယ်။ ဒီကောင်တွေကတော့ category module တွေပေါ့။"
    }
    ,
    {
        id : 9,
        "title" : "Session နဲ့ Cookie အကြောင်းတစ်စေ့တစ်စောင်း",
        "image" : "https://static.javatpoint.com/difference/images/session-vs-cookies.png",
        "description" : "Cookie ဆိုတာက ကျနော်တို့ ရဲ့ computer မှာ သိမ်းထားတဲ့ text file အသေးစားလေးတွေပါ၊ file တွေထဲမှာ key value lookup ပုံစံနဲ့ data လေးတွေ store လုပ်ထားပါတယ်။ ဥပမာ- name,mgmg . age,23. Address,yagon စသည်ဖြင့်ဒီလိုပုံစံလေးတွေပေါ့။ ဘာလို့ cookie ကိုသုံးတာလဲ။ အဓိက ကတော့ server နဲ့ browser ကြားမှာ data information တွေကို carry လုပ်ဖို့သုံးပါတယ်။ Cookie တွေကို client side ဖြစ်တဲ့ browser မှာပဲ store လုပ်ထားတာဖြစ်ပါတယ်။ ဥပမာအနေနဲ့ ပြောရရင် ကျနော်တို့ website တစ်ခုကို visit လုပ်ပြီး login form ဖြည့်တယ်ဆိုပါတော့၊ လိုတဲ့ information တွေဖြည့်တယ်။ ဖြည့်ပြီးသွားတဲ့ data တွေကို server က receive လုပ်ပြီးတော့ browser ဆီကို cookie set တွေအနေနဲ့ ပြန်ပို့တယ်။ browser က save လုပ်ထားလိုက်တယ်။ နောက်တစ်ကြိမ် အဲ့ website ကို သွားရင် browser ကနေ သိမ်းထားတဲ့ cookie တွေကို server ဆီပို့တယ် server က identify လုပ်တယ်။ ဒါကြောင့်မို့ အကြိမ်တိုင်း login လုပ်စရာမလိုတော့ဘူး၊ server နဲ့ browser ကြားမှာ cookie set communication ရှိနေတဲ့အတွက်ကြောင့် ဖြစ်ပါတယ်။ Cookie တွေရဲ့ duration ကို cookie တွေ create လုပ်တဲ့အချိန်မှာ တစ်ခါတည်း သတ်မှတ်ထားလို့ရပါတယ်။ ကိုယ်ကြိုက်တဲ့ အချိန်အတိုင်းအတာ တစ်ခုအထိ သတ်မှတ်ထားပြီး အဲ့ဒီ အချိန်ကျော်သွားပြီဆိုရင်တော့ destroy ဖြစ်သွားမှာပါ။ တစ်ခုမှတ်ထားရမှာက cookie တွေကို code နဲ့ အဆင်ပြေသလို manipulate လုပ်လို့ရပါတယ်။ creation, path, expiration date, domain, security, deletion , conditional statement (cookie exist or not )စသည်ဖြင့် research လုပ်ပြီးစမ်းကြည့်လို့ရပါတယ်။ browser ကနေ inspect ထောက်ပြီး application or storage tab ထဲမှာလည်း cookie တွေကို သွားကြည့်နိုင်ပါတယ်။ Session ရဲ့ သဘောတရားနဲ့ cookie & session ဆက်စပ်ပြီးအလုပ်လုပ်ပုံ Cookie မတူတာတဲ့အချက်က session က server ပေါ်မှာ store လုပ်တယ်။ store လုပ်တဲ့ format က cookie လိုပဲ key value pair လေးတွေကို temporary directory လုပ်ပြီး သိမ်းပါတယ်။ Session နဲ့ cookie ဘယ်လို ဆက်စပ်ပြီး အလုပ်လုပ်လဲဆိုတော့ Session တိုင်းမှာ id ရှိပါတယ်။ ဥပမာ SESSID=1231239718 , အဲ့ဒီ session ID ကို client browser ထဲက cookie တွေထဲမှာသိမ်းထားပါတယ်။ ဆိုတော့ အလုပ်လုပ်ပုံက ကျနော်က website တစ်ခုဆီကိုသွားတယ်ဆိုရင် Browser ကနေ server ဆီ request ပို့ပါတယ်။ Request အသစ်ဆိုရင် server ကနေ sessionid နဲ့အတူ cookie ပြန်ပို့တယ် (browser က store လုပ်တယ်)။ Sessionid cookie ထဲမှာရှိတယ်ဆိုရင် (request အသစ်မဟုတ်ရင်) အဲ့ဒီ session နဲ့ သိမ်းထားတဲ့ information တွေကို retrieve လုပ်ပါတယ်။ Ps. Cookies တွေ session တွေပို့တယ်ယူတယ်ဆိုတာ data တွေ carry လုပ်ဖို့လိုတဲ့ အချိန်မှာပဲ လုပ်တာဖြစ်ပါတယ်။ request တိုင်းကိုလုပ်နေတာမဟုတ်ပါဘူး။ နောက်တစ်ခုမှတ်ထားရမှာက sensitive ဖြစ်တဲ့ information တွေကို client side မှာ cookie အနေနဲ့ store မလုပ်ထားသင့်ပါဘူး။ cookie တွေကို manipulate လုပ်ရတာက လွယ်ကူတဲ့အတွက် security concern အရ information တွေကို cookie မှာသိမ်းတော့မယ်ဆို sensitive ဖြစ်တဲ့ information တွေမပါဖို့အရေးကြီးပါတယ်။"
    }
    ,
    {
        id : 10,
        "title" : "MVC (Model , View & Controller)",
        "image" : "https://aprogrammer.blog/storage/blog/images/29.png",
        "description" : "Programming မှာ MVC ပြောလိုက်ပြီဆိုရင် လူတိုင်းနဲ့ စိမ်းတော့တဲ့ အရာတစ်ခုတော့ မဟုတ်ပါဘူး။ ဒီ article ကတော့ MVC ဆိုတာကို အခုမှသိတဲ့လူရော၊ သိပြီးသားဖြစ်ပေမဲ့လည်း တိတိကျကျ မသိသေးသူအတွက်ရော ရှင်းရှင်းလင်းလင်းနားလည်သွားရအောင် ဆိုတဲ့ ရည်ရွယ်ချက်နဲ့ ရေးလိုက်ပါတယ်။ MVC ဆိုတဲ့ acronym ပေါ်လာရတဲ့အကြောင်းရင်း ကရှင်းပါတယ်။ MVC မပေါ်ခင်က သုံးခဲ့တဲ့ traditional approach တွေက တစ်ဖြည်းဖြည်းနဲ့ သုံးလို့အဆင်မပြေလာတာကြောင့်ပါ။ ဒီ article မှာ MVC က ကျနော်တို့ အရင်က သုံးခဲ့ကြတဲ့ traditional approach ထက်ဘာတွေသာသွားမလဲဆိုတာကိုလည်း ထည့်သွင်းဆွေးနွေးသွားပါမယ်။ MVC ဆိုတာက Model, View, Controller ကို ဆိုလိုတယ်။ ပုံမှန် traditional approach မှာ Input လုပ်တယ် process လုပ်တယ် နောက်ဆုံးမှာ Output ထွက်တယ်။ MVC မှာတော့ Controller ကနေ Model ကိုသွားတယ် Model ကနေမှ View ကိုသွားတယ်။ Model က controller နဲ့ view ကြားကို ဆက်စပ်ပေးထားတဲ့ အရာတစ်ခုလို့လဲပြောလို့ရတယ်။ နောက်တစ်ခုက traditional မှာ UI coding , business logic coding & application domain coding တွေအားလုံးကို တစ်ဖိုင်ထဲမှာပဲ စုပြီး ရေးထားတဲ့အတွက် code ရေးရတာများလာတာနဲ့အမျှ Maintain လုပ်ရတာတို့ testing လုပ်ရတာတို့ ခက်လာတယ်။ application ကလည်း နောက်ပိုင်းမှာ robust ဖြစ်မလာတော့ဘူး။ MVC ကို invent လုပ်ရတဲ့ အကြောင်းရင်းကလဲ အဲ့လို ဖြစ်နေတဲ့ issues တွေကို cover လုပ်နိုင်ဖို့ပဲ။ code elements တွေကြားမှာ loosely coupling လုပ်ရင်းနဲ့ input logic, business logic , UI logic တွေကို separate လုပ်ထားတယ်။ ဘယ် logic ကဘယ်နေရာမှာ ရှိသင့်တယ် စသည်ဖြင့်ပေါ့၊ ဥပမာ UI logic ဆို view ကိုသွား Input နဲ့ functional Logic ဆို controller ကိုသွား business logic ဆို model ကိုသွား စသည်ဖြင့် ခွဲထုတ်ထားလို့ ရတယ်။ နောက်ပိုင်း pattern တွေထပ်လေ့လာရင်းနဲ့ ထပ်ခွဲထုတ်လို့ရသေးတယ်။ အဲ့လို ခွဲထုတ်လိုက်ခြင်းအားဖြင့် code complexity ကိုလျော့ချနိုင်လာမယ်။ business code ပဲဖြစ်ဖြစ် UI code ပဲဖြစ်ဖြစ် တစ်ခုတည်းကိုပဲ foucs လုပ်ပြီး ရေးလို့ရတယ်။ MVC Framework ကို သေချာ define လုပ်ရမယ်ဆိုရင်ဖြင့်   -------    Models---> ရှင်းရှင်းလင်းလင်း မှတ်မယ်ဆိုရင် Model က application ရဲ့ data domain နဲ့ ပတ်သတ်တဲ့ အပိုင်းတွေကို operate လုပ်ရတဲ့ layer တစ်ခုလို့မှတ်လို့ရတယ်။ controller က view ဆီကို data တွေ pass လုပ်ဖို့အတွက် data တွေယူဖို့ကို model နဲ့ ချိတ်ဆက်ပြီး operation တွေလုပ်ရတယ်၊ retrieving, inserting, updating , deleting အစရှိတဲ့ အရာတွေကိုလည်း Model နဲ့ ပဲချိတ်ပြီး အလုပ်လုပ်တယ်။ ဒီလောက်ဆို application ရဲ့ core data တွေအကုန်လုံးကို model က handle လုပ်ထားတယ်ဆိုတာမြင်လောက်ပြီ ၊ ဒါပေမဲ့တစ်ချို့ application အသေးတွေမှာ model ဆိုတဲ့ physical layer ကြီးပဲ သက်သက်ရှိမနေဘူး၊ ဆိုလိုချင်တာက application က dataset တစ်ခုကို လှမ်းဖတ်ပြီး တိုက်ရိုက်ပဲ view ကို pass လုပ်ပေးလိုက်တယ်၊ လုပ်လိုက်တဲ့နေရာမှာ model ဆိုတဲ့ physical layer နဲ့ သူ့ရဲ့ class တွေဘာတစ်ခုမှမရှိဘူး ဆိုတဲ့ အတွက် ဒီလိုအချိန်မှာဆို အဲ့ဒီ dataset ကပဲ model object ရဲ့ တာဝန်တွေကို ယူလိုက်တဲ့ သဘောမျိုးဖြစ်သွားတယ်။ Views--->Views ကတော့ ရှင်းတယ်၊ User Interface ပဲ။ Controller ကပေးလိုက်တဲ့ model က data တွေကို display လုပ်တယ်။ User Interaction တွေကို Controller ဆီပြန် pass လုပ်တယ်။ Controllers--->Controllers တွေကတော့ View ကနေ လာတဲ့ User Interaction တွေကို ပြန်catch လုပ်ပြီး model နဲ့ အတူ process လုပ်တယ်။ လုပ်ရမယ့် operation တွေပြီးတာနဲ့ view ကို data တွေနဲ့ အတူ render လုပ်တယ်။ ဒီထက်ပိုပြီး ရှင်းအောင် ပြောရမယ်ဆိုရင် MVC မှာ View က data display only အတွက်ပဲသုံးတယ်။ controller က user inputs တွေကို handle လုပ်ပြီး respond ပြန်လုပ်တယ်၊ ဥပမာ user inputs တွေရလာပြီ၊ query string တွေ ဆောက်တယ်၊အဲ့ဒီ query string တွေကို Model ကို ပေးလိုက်တယ်၊ Model က ရလာတဲ့ query တွေကို database ပေါ်မှာအလုပ်လုပ်တယ်။ MVC ပေါ်လာပြီးနောက်ပိုင်း software development က traditional approach ထက်စာရင် code reuse low complexity can focus on specific logic code simultaneous application development စသည်ဖြင့် သိသိသာသာတိုးတက်လာတဲ့အတွက် ထွက်လာတဲ့ application တွေကလည်း ပိုပြီးတော့မှ smooth & robust ဖြစ်လာတယ်။ အခုလက်ရှိ platform တော်တော်များများ မှာလည်း MVC architecture ကိုသုံးနေကြပါတယ်။"
    }
]

export default DATA;